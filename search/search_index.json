{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Analysis Correlation Engine GUI \u00b6 If you're looking for the main ACE documentation, check out the ace2-core docs . Quick Start \u00b6 Coming soon...","title":"Analysis Correlation Engine GUI"},{"location":"#analysis-correlation-engine-gui","text":"If you're looking for the main ACE documentation, check out the ace2-core docs .","title":"Analysis Correlation Engine GUI"},{"location":"#quick-start","text":"Coming soon...","title":"Quick Start"},{"location":"development/backend/database/","text":"Database \u00b6 Schema definitions \u00b6 The database tables used by the FastAPI backend are all defined using SQLAlchemy. The table models are stored in backend/app/db/models.py . Alembic \u00b6 Creating revisions \u00b6 The models are applied to the database using Alembic . Whenever you make any changes to the database models, you will need to generate a new Alembic \"revision\". You can use the bin/db-revision.sh script to help create a new revision after you've made some changes to the database models: bin/db-revision.sh \"Some short note\" This script uses Alembic's \"autogenerate\" feature to create what it thinks is the correct database migration script for the changes you made. Autogenerate is not always perfect , so you should always verify the migration script it creates before committing it to the repo (and applying it in production) to make sure what will be applied to the database is correct. The migration scripts can be found in backend/db/migrations/versions/ . An example migration script for creating the \"tag\" database table is shown below: \"\"\"Initial revision Revision ID: 03fe4895893f Revises: Create Date: 2021-04-16 21:08:29.237142 \"\"\" from alembic import op import sqlalchemy as sa # revision identifiers, used by Alembic revision = '03fe4895893f' down_revision = None branch_labels = None depends_on = None def upgrade () -> None : # ### commands auto generated by Alembic - please adjust! ### op . create_table ( 'tag' , sa . Column ( 'id' , sa . Integer (), nullable = False ), sa . Column ( 'name' , sa . String (), nullable = True ), sa . PrimaryKeyConstraint ( 'id' ) ) op . create_index ( op . f ( 'ix_tag_id' ), 'tag' , [ 'id' ], unique = False ) # ### end Alembic commands ### def downgrade () -> None : # ### commands auto generated by Alembic - please adjust! ### op . drop_index ( op . f ( 'ix_tag_id' ), table_name = 'tag' ) op . drop_table ( 'tag' ) # ### end Alembic commands ### This script shows you what it will do when you issue the \"upgrade\" command to the database as well as if you need to revert and issue the \"downgrade\" command. You can manually edit this migration script if something is incorrect. Applying revisions \u00b6 Once you have a new revision you'd like to apply to the database, you can either use the bin/reset-dev-container.sh script to rebuild your entire development environment (which will automatically apply the Alembic database revisions), or you can use the bin/db-upgrade.sh script to apply the revisions without erasing and rebuilding the development environment.","title":"Database"},{"location":"development/backend/database/#database","text":"","title":"Database"},{"location":"development/backend/database/#schema-definitions","text":"The database tables used by the FastAPI backend are all defined using SQLAlchemy. The table models are stored in backend/app/db/models.py .","title":"Schema definitions"},{"location":"development/backend/database/#alembic","text":"","title":"Alembic"},{"location":"development/backend/database/#creating-revisions","text":"The models are applied to the database using Alembic . Whenever you make any changes to the database models, you will need to generate a new Alembic \"revision\". You can use the bin/db-revision.sh script to help create a new revision after you've made some changes to the database models: bin/db-revision.sh \"Some short note\" This script uses Alembic's \"autogenerate\" feature to create what it thinks is the correct database migration script for the changes you made. Autogenerate is not always perfect , so you should always verify the migration script it creates before committing it to the repo (and applying it in production) to make sure what will be applied to the database is correct. The migration scripts can be found in backend/db/migrations/versions/ . An example migration script for creating the \"tag\" database table is shown below: \"\"\"Initial revision Revision ID: 03fe4895893f Revises: Create Date: 2021-04-16 21:08:29.237142 \"\"\" from alembic import op import sqlalchemy as sa # revision identifiers, used by Alembic revision = '03fe4895893f' down_revision = None branch_labels = None depends_on = None def upgrade () -> None : # ### commands auto generated by Alembic - please adjust! ### op . create_table ( 'tag' , sa . Column ( 'id' , sa . Integer (), nullable = False ), sa . Column ( 'name' , sa . String (), nullable = True ), sa . PrimaryKeyConstraint ( 'id' ) ) op . create_index ( op . f ( 'ix_tag_id' ), 'tag' , [ 'id' ], unique = False ) # ### end Alembic commands ### def downgrade () -> None : # ### commands auto generated by Alembic - please adjust! ### op . drop_index ( op . f ( 'ix_tag_id' ), table_name = 'tag' ) op . drop_table ( 'tag' ) # ### end Alembic commands ### This script shows you what it will do when you issue the \"upgrade\" command to the database as well as if you need to revert and issue the \"downgrade\" command. You can manually edit this migration script if something is incorrect.","title":"Creating revisions"},{"location":"development/backend/database/#applying-revisions","text":"Once you have a new revision you'd like to apply to the database, you can either use the bin/reset-dev-container.sh script to rebuild your entire development environment (which will automatically apply the Alembic database revisions), or you can use the bin/db-upgrade.sh script to apply the revisions without erasing and rebuilding the development environment.","title":"Applying revisions"},{"location":"development/backend/environment_variables/","text":"Environment Variables \u00b6 The backend container relies on a number of environment variables. For the development environment, these are automatically generated by the bin/reset-dev-container.sh script and stored inside of the .ace2.env file inside of your home directory. These environment variables will need to be set by other means if you are running this application in production. FastAPI backend variables \u00b6 These variables are used by the FastAPI backend application. ACE_DEV : If set (to anything), the application will run in development-mode, which means that the Alembic database migrations will be applied and the database seeded with basic information automatically when the application starts. COOKIES_SAMESITE : The SameSite value to use when sending cookies. The development environment uses lax . Defaults to lax . COOKIES_SECURE : True/False whether or not you want to require HTTPS when sending cookies. The development environment uses False . Defaults to True . CORS_ORIGINS : A comma-separated string of origins to allow with CORS. For example, your development environment should be set to something like http://localhost:8080,http://localhost:8888 depending on which port the GUI is served from. DATABASE_URL : The connection string used to connect to the PostgreSQL server. It should be in the form of postgresql://user:password@hostname[:port]/dbname . JWT_ACCESS_EXPIRE_SECONDS : The number of seconds after which an access token will expire. The development environment uses 900 (15 minutes) by default. JWT_ALGORITHM : Sets the algorithm to use for signing the tokens. The development environment uses HS256 by default. JWT_REFRESH_EXPIRE_SECONDS : The number of seconds after which a refresh token will expire. The development environment uses 43200 (12 hours) by default. JWT_SECRET : The secret key/password to use when signing and decoding tokens. The development environment generates a random 32 character string . PostgreSQL container variables \u00b6 These variables are used by the PostgreSQL server container to initialize the database. POSTGRES_DB : The name of the database to create. The development environment uses ace . POSTGRES_USER : The user to use to connect to the PostgreSQL server. The development environment uses ace . POSTGRES_PASSWORD : The password to use to connect to the PostgreSQL server. The development environment generates a random 32 character string .","title":"Environment Variables"},{"location":"development/backend/environment_variables/#environment-variables","text":"The backend container relies on a number of environment variables. For the development environment, these are automatically generated by the bin/reset-dev-container.sh script and stored inside of the .ace2.env file inside of your home directory. These environment variables will need to be set by other means if you are running this application in production.","title":"Environment Variables"},{"location":"development/backend/environment_variables/#fastapi-backend-variables","text":"These variables are used by the FastAPI backend application. ACE_DEV : If set (to anything), the application will run in development-mode, which means that the Alembic database migrations will be applied and the database seeded with basic information automatically when the application starts. COOKIES_SAMESITE : The SameSite value to use when sending cookies. The development environment uses lax . Defaults to lax . COOKIES_SECURE : True/False whether or not you want to require HTTPS when sending cookies. The development environment uses False . Defaults to True . CORS_ORIGINS : A comma-separated string of origins to allow with CORS. For example, your development environment should be set to something like http://localhost:8080,http://localhost:8888 depending on which port the GUI is served from. DATABASE_URL : The connection string used to connect to the PostgreSQL server. It should be in the form of postgresql://user:password@hostname[:port]/dbname . JWT_ACCESS_EXPIRE_SECONDS : The number of seconds after which an access token will expire. The development environment uses 900 (15 minutes) by default. JWT_ALGORITHM : Sets the algorithm to use for signing the tokens. The development environment uses HS256 by default. JWT_REFRESH_EXPIRE_SECONDS : The number of seconds after which a refresh token will expire. The development environment uses 43200 (12 hours) by default. JWT_SECRET : The secret key/password to use when signing and decoding tokens. The development environment generates a random 32 character string .","title":"FastAPI backend variables"},{"location":"development/backend/environment_variables/#postgresql-container-variables","text":"These variables are used by the PostgreSQL server container to initialize the database. POSTGRES_DB : The name of the database to create. The development environment uses ace . POSTGRES_USER : The user to use to connect to the PostgreSQL server. The development environment uses ace . POSTGRES_PASSWORD : The password to use to connect to the PostgreSQL server. The development environment generates a random 32 character string .","title":"PostgreSQL container variables"},{"location":"development/gui/","text":"ACE2 GUI Development Guide \u00b6 Initial setup \u00b6 This project has VSCode devcontainer support to ensure that anyone working on the project does so in a consistent environment as well as follows the same formatting/styling guidelines. Required setup \u00b6 In order to work within the devcontainer, you will need the following installed on your system: Docker VSCode Remote Development VSCode extension pack Running the frontend application inside of the devcontainer is possible but can be very slow, especially when relying on hot-reload after you make changes. In order to run the frontend application locally (outside of the devcontainer), you will also need to install: Node.js 16 NOTE: If you are developing in Windows, you will need to make sure that you have WSL 2 set up and properly configured with Docker. That is outside the scope of this documentation, but you can find steps here . Working in the VSCode devcontainer \u00b6 When you open the project in VSCode, it will detect the devcontainer configuration and prompt you to reopen it inside of the container: Once you choose the Reopen in Container option, VSCode will work on building the environment. Once it is complete, you can open a terminal within VSCode to interact with the application: Any work done on the application should be done through the devcontainer. If you make a change to the devcontainer configuration (found in the .devcontainer directory), you can rebuild the devcontainer by clicking on Dev Container: ACE2 AMS GUI in the lower-left corner of VSCode and then selecting the Rebuild Container option in the menu that opens. Starting the application \u00b6 You can start the application so that it uses hot-reloading anytime you change a file: npm run serve You will then be able to access the application on your local system (outside of the devcontainer) at http://localhost:8080 . NOTE: You can run the application from within the VSCode devcontainer, but the performance will be quite slow. It is best to run it locally on your host system. Setting Vue environment variables \u00b6 Vue needs to know the base URL to the backend API. When you run the application within the VSCode devcontainer, this is already taken care of by the Dockerfile. However, when you run the application locally on your host system for better performance, you will need to properly set the VUE_APP_BACKEND_URL variable. Create a file named .env.development.local in the root of the project (which is ignored by Git) with the following contents: VUE_APP_BACKEND_URL=http://localhost:8888/api By default, the ACE2 AMS API runs on port 8888 when you start it using the instructions as outlined . If for some reason you have changed that port, also remember to change the port in the .env.development.local file. NOTE: You can create a file named .env.production.local with the same variable inside of it that you set to wherever you are hosting the production ACE2 AMS API. This file will be used when building the frontend for production. Interaction with the ACE2 AMS API \u00b6 To get the full functionality out of the GUI application, it must be able to communicate with its backend API. You will want to ensure you are running the FastAPI backend, which can be found at https://github.com/ace-ecosystem/ace2-ams-api . Within your cloned ace2-ams-api repository, you can build the development environment by running: bin/reset-dev-container.sh This script will generate random passwords for the database user and the secret key used for JWTs. If you need to access these, you can view them in the $HOME/.ace2.env file, which configures the environment variables that will be loaded into the database container. Once the both the frontend and backend development environments are built and started, you can access the components: Frontend: http://localhost:8080 Backend API Swagger documentation: http://localhost:8888/docs Backend API ReDoc documentation: http://localhost:8888/redoc The documentation for the ace2-ams-api project can be found at https://ace-ecosystem.github.io/ace2-ams-api/ . Managing NPM packages \u00b6 You should not directly edit the dependencies or devDependencies inside of package.json or anything in package-lock.json . Any changes to packages should be performed via the npm command : Install new dependency package \u00b6 You would install a package like this if it is something the final compiled application needs: npm install <package> Install new dev dependency package \u00b6 You would install a package like this if it is only needed during development: npm install -D <package> Uninstall package \u00b6 You can uninstall/remove a package regardless of how it was installed by: npm uninstall <package> Running tests \u00b6 This application has a suite of unit tests performed by Jest and end-to-end tests performed by Cypress . Unit tests \u00b6 You can execute the unit tests by running: npm run test:unit NOTE: Running the unit tests within the devcontainer will work, but the performance will be quite slow. It is best to run them locally on your host system. End-to-end tests \u00b6 You can execute the end-to-end tests on your host system by running: npm run test:e2e Test Runner \u00b6 Cypress also comes with an amazing Test Runner that lets you see and interact with the tests in your local web browser. This can be helpful when writing end-to-end tests to ensure they are working properly as well as any debugging you might need to do. However, this will need to be performed on your local system ouside of the devcontainer. To do this, you will need to have Node.js 16 installed on your local system . Step 1: Run the application in production mode: npm run production Step 2: In another terminal on your local system (but still inside of the project directory), open the Test Runner: npx cypress open For more information on what you can do with the Test Runner, view the Test Runner documentation .","title":"ACE2 GUI Development Guide"},{"location":"development/gui/#ace2-gui-development-guide","text":"","title":"ACE2 GUI Development Guide"},{"location":"development/gui/#initial-setup","text":"This project has VSCode devcontainer support to ensure that anyone working on the project does so in a consistent environment as well as follows the same formatting/styling guidelines.","title":"Initial setup"},{"location":"development/gui/#required-setup","text":"In order to work within the devcontainer, you will need the following installed on your system: Docker VSCode Remote Development VSCode extension pack Running the frontend application inside of the devcontainer is possible but can be very slow, especially when relying on hot-reload after you make changes. In order to run the frontend application locally (outside of the devcontainer), you will also need to install: Node.js 16 NOTE: If you are developing in Windows, you will need to make sure that you have WSL 2 set up and properly configured with Docker. That is outside the scope of this documentation, but you can find steps here .","title":"Required setup"},{"location":"development/gui/#working-in-the-vscode-devcontainer","text":"When you open the project in VSCode, it will detect the devcontainer configuration and prompt you to reopen it inside of the container: Once you choose the Reopen in Container option, VSCode will work on building the environment. Once it is complete, you can open a terminal within VSCode to interact with the application: Any work done on the application should be done through the devcontainer. If you make a change to the devcontainer configuration (found in the .devcontainer directory), you can rebuild the devcontainer by clicking on Dev Container: ACE2 AMS GUI in the lower-left corner of VSCode and then selecting the Rebuild Container option in the menu that opens.","title":"Working in the VSCode devcontainer"},{"location":"development/gui/#starting-the-application","text":"You can start the application so that it uses hot-reloading anytime you change a file: npm run serve You will then be able to access the application on your local system (outside of the devcontainer) at http://localhost:8080 . NOTE: You can run the application from within the VSCode devcontainer, but the performance will be quite slow. It is best to run it locally on your host system.","title":"Starting the application"},{"location":"development/gui/#setting-vue-environment-variables","text":"Vue needs to know the base URL to the backend API. When you run the application within the VSCode devcontainer, this is already taken care of by the Dockerfile. However, when you run the application locally on your host system for better performance, you will need to properly set the VUE_APP_BACKEND_URL variable. Create a file named .env.development.local in the root of the project (which is ignored by Git) with the following contents: VUE_APP_BACKEND_URL=http://localhost:8888/api By default, the ACE2 AMS API runs on port 8888 when you start it using the instructions as outlined . If for some reason you have changed that port, also remember to change the port in the .env.development.local file. NOTE: You can create a file named .env.production.local with the same variable inside of it that you set to wherever you are hosting the production ACE2 AMS API. This file will be used when building the frontend for production.","title":"Setting Vue environment variables"},{"location":"development/gui/#interaction-with-the-ace2-ams-api","text":"To get the full functionality out of the GUI application, it must be able to communicate with its backend API. You will want to ensure you are running the FastAPI backend, which can be found at https://github.com/ace-ecosystem/ace2-ams-api . Within your cloned ace2-ams-api repository, you can build the development environment by running: bin/reset-dev-container.sh This script will generate random passwords for the database user and the secret key used for JWTs. If you need to access these, you can view them in the $HOME/.ace2.env file, which configures the environment variables that will be loaded into the database container. Once the both the frontend and backend development environments are built and started, you can access the components: Frontend: http://localhost:8080 Backend API Swagger documentation: http://localhost:8888/docs Backend API ReDoc documentation: http://localhost:8888/redoc The documentation for the ace2-ams-api project can be found at https://ace-ecosystem.github.io/ace2-ams-api/ .","title":"Interaction with the ACE2 AMS API"},{"location":"development/gui/#managing-npm-packages","text":"You should not directly edit the dependencies or devDependencies inside of package.json or anything in package-lock.json . Any changes to packages should be performed via the npm command :","title":"Managing NPM packages"},{"location":"development/gui/#install-new-dependency-package","text":"You would install a package like this if it is something the final compiled application needs: npm install <package>","title":"Install new dependency package"},{"location":"development/gui/#install-new-dev-dependency-package","text":"You would install a package like this if it is only needed during development: npm install -D <package>","title":"Install new dev dependency package"},{"location":"development/gui/#uninstall-package","text":"You can uninstall/remove a package regardless of how it was installed by: npm uninstall <package>","title":"Uninstall package"},{"location":"development/gui/#running-tests","text":"This application has a suite of unit tests performed by Jest and end-to-end tests performed by Cypress .","title":"Running tests"},{"location":"development/gui/#unit-tests","text":"You can execute the unit tests by running: npm run test:unit NOTE: Running the unit tests within the devcontainer will work, but the performance will be quite slow. It is best to run them locally on your host system.","title":"Unit tests"},{"location":"development/gui/#end-to-end-tests","text":"You can execute the end-to-end tests on your host system by running: npm run test:e2e","title":"End-to-end tests"},{"location":"development/gui/#test-runner","text":"Cypress also comes with an amazing Test Runner that lets you see and interact with the tests in your local web browser. This can be helpful when writing end-to-end tests to ensure they are working properly as well as any debugging you might need to do. However, this will need to be performed on your local system ouside of the devcontainer. To do this, you will need to have Node.js 16 installed on your local system . Step 1: Run the application in production mode: npm run production Step 2: In another terminal on your local system (but still inside of the project directory), open the Test Runner: npx cypress open For more information on what you can do with the Test Runner, view the Test Runner documentation .","title":"Test Runner"}]}